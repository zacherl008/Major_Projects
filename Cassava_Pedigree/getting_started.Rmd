---
title: "Pedigree Verification"
author: "Bryan"
date: "June 13, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Packages

First lets install and load a couple of packages that we'll need. *pedigreemm* for calculating additive relationships and *proxy* for calculating genetic distances.


library(pedigreemm)
library(proxy)


## Load pedigrees from Potato Paper

Ok, time to work with real data. Download the csv files from the potato paper (https://link.springer.com/article/10.1007%2Fs12230-016-9556-y). They are included at the very end of the paper in the supplementary material section.

```{r}
#Potato pedigrees and Additive Relationships

# set working directory and read in pedigree csv file
setwd("/home/bryan/Downloads")
potato_ped <- read.csv("12230_2016_9556_MOESM1_ESM.csv", header = TRUE, check.names = FALSE)

# use editPed to order the pedigree by generation and make sure there is a row for each unique accession name, including parents
potatoP2= editPed(dam=potato_ped$Mother, sire=potato_ped$Father, label=potato_ped$Name)
head(potatoP2)

# read records corrected by editPed into a formal pedigree object
potatoP3= pedigree(potatoP2$sire, potatoP2$dam, potatoP2$label)
head(potatoP3)

# calculate matrix of additive relationship scores based on pedigree
potatoAmat <- getA(potatoP3)
head(potatoAmat)
```

## Load marker/dosage matrix from Potato Paper

```{r}
#Potato Markers and Genetic Distances

# read in marker/dosage csv file
potato_markers <- read.csv("12230_2016_9556_MOESM2_ESM.csv", header = TRUE, check.names = FALSE)

# transpose markers so accessions are rows and markers are columns
tpotato_markers <- t(potato_markers)

# column names that should form the header are now in first row. So replace the header with the first row
colnames(tpotato_markers) <- as.character(unlist(tpotato_markers[1,]))
tpotato_markers = tpotato_markers[-1, ]

# set class as numeric so all matrix values will work in calculations, including NAs
class(tpotato_markers) <- "numeric"

# calculate Euclidean distances
potato_marker_distances <- dist(tpotato_markers, method = "Euclidean")

# look at the structure of the result object - its not a matrix anymore, its a 'dist'! 
str(potato_marker_distances) 

# convert distances to a matrix so they are easier to manipulate
dist_matrix = as.matrix(potato_marker_distances)

# check dimensions of our matrices
dim(potatoAmat)
dim(dist_matrix)

# We have too many genotypes, so make a list of all the accessions in the pedigree matrix, and use it to subset the genetic distance matrix
include_list <- labels(potatoAmat[,"W8848-3"]) 
subset_matrix <- geno[rownames(geno) %in% include_list, colnames(geno) %in% include_list] 
dim(subset_matrix) # now it should match

```

## Recreate Potato Paper Graph with ggplot2

```{r}
# install and load ggplot2 (Grammar of Graphics package)
install.packages("ggplot2")
library(ggplot2)
help(ggplot)

# get values for W8848-3, excluding self comparisons, from matrices
x <- potatoAmat[!rownames(potatoAmat) %in% "W8848-3","W8848-3"]
y <- subset_matrix["W8848-3",!colnames(subset_matrix) %in% "W8848-3"]

# ensure both vectors are in same order by sorting with accession names
xord <- order(names(x))
x <- x[xord]
yord <- order(names(y))
y <- y[yord]

# create plot!
ggplot()+ggtitle("W8848â€“3 Plot recreated")+labs(x="Additive relationship",y="Marker-based distance")+geom_text(aes(x=x,y=y,label=names(x)))

```


## Now apply the same techniques to the data from Cassavabase!

```{r}

#Cassava pedigrees and Additive Relationships

ped <- read.table ("/home/klz26/Downloads/pedigree1.txt", header = FALSE, sep = "\t", check.names = FALSE, stringsAsFactors = FALSE
                   ,fill= FALSE)
colnames(ped)[1] <- "Name"
colnames(ped)[2] <- "Mother"
colnames(ped)[3] <- "Father"
colnames(ped)[4] <- "Cross Type"
ped[4] <- NULL

# use editPed to order the pedigree by generation and make sure there is a row for each unique accession name, including parents
P2= editPed(dam=ped$Mother, sire=ped$Father, label=ped$Name)
head(P2)

# read records corrected by editPed into a formal pedigree object
P3= pedigree(P2$sire, P2$dam, P2$label)
head(P3)

# calculate matrix of additive relationship scores based on pedigree
Amat <- getA(P3)
Amat

#Cassava Markers and Genetic Distances

markers <- read.table ("/home/klz26/Downloads/13genotypes-p3.txt", header = TRUE, check.names = FALSE, stringsAsFactors = FALSE)
colnames(markers) <- gsub('\\|[^|]+$', '', colnames(markers))

# column names that should form the header are now in first row. So replace the header with the first row
rownames(markers) <- as.character(unlist(markers[,1]))
markers = markers[,-1]

# set class as numeric so all matrix values will work in calculations, including NAs
# class(markers) <- "numeric"

# calculate Euclidean distances
marker_distances <- dist(markers, method = "Euclidean", by_rows = FALSE)

# look at the structure of the result object - its not a matrix anymore, its a 'dist'! 
str(marker_distances) 

# convert distances to a matrix so they are easier to manipulate
dist_matrix = as.matrix(marker_distances)

# check dimensions of our matrices
dim(Amat)
dim(dist_matrix)

# We have too many genotypes, so make a list of all the accessions in the pedigree matrix, and use it to subset the genetic distance matrix
include_list <- labels(Amat[,"UG120078"])
include_list
subset_matrix <- dist_matrix[rownames(dist_matrix) %in% include_list, colnames(dist_matrix) %in% include_list] 
dim(subset_matrix) # should be same now

include_list2 <-labels(dist_matrix[,"UG120078"])
include_list2
subset_matrix2 <-Amat[rownames(Amat) %in% include_list2, colnames(Amat) %in% include_list2]
dim(subset_matrix2)

## QC graphs with ggplot2

library(ggplot2)
help(geom_text)

# get values for COB1103 excluding self comparisons, from matrices
x <- Amat[!rownames(Amat) %in% "UG120078","UG120078"]
y <- subset_matrix["UG120078",!colnames(subset_matrix) %in% "UG120078"]

x <- dist_matrix[!rownames(dist_matrix) %in% "UG120078","UG120078"]
y <- subset_matrix["UG120078",!colnames(subset_matrix) %in% "UG120078"]

# ensure both vectors are in same order by sorting with accession names
xord <- order(names(x))
x <- x[xord]
yord <- order(names(y))
y <- y[yord]

# create plot!
ggplot()+ggtitle("COB1103 Relationships")+labs(x="Additive relationship",y="Marker-based distance")+geom_text(aes(x=x,y=y,label=names(x)))

# get values for COB477 excluding self comparisons, from matrices
x <- Amat[!rownames(Amat) %in% "COB477","COB477"]
y <- subset_matrix["COB477",!colnames(subset_matrix) %in% "COB477"]

# ensure both vectors are in same order by sorting with accession names
xord <- order(names(x))
x <- x[xord]
yord <- order(names(y))
y <- y[yord]

# create plot!
ggplot()+ggtitle("COB477 Relationships")+labs(x="Additive relationship",y="Marker-based distance")+geom_text(aes(x=x,y=y,label=names(x)),size=2.5)+expand_limits(x=c(-0.03,0.53))



```


